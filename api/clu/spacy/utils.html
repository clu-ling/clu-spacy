<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>clu.spacy.utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clu.spacy.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Sequence, List, Tuple, Dict, Union, Iterable
import spacy
from spacy.tokens import Doc as SpacyDoc
from spacy.tokens import Span, Token
from processors.ds import Document as CluDocument
from processors.ds import Sentence

DEFAULT_PIPELINE = &#34;en_core_web_sm&#34;

class ConverterUtils:

    &#34;&#34;&#34;
        A collection of utlity methods for coverting between SpaCy Doc and processor Document containers.

        Supported Containers
        --------------------
        SpaCy Doc : Sequence[Token]
                A sequence of SpaCy Token objects.

        CluDocument : Sequence[Sentence]
                A sequence of processor Setence objects.

        Methods
        -------
        to_clu_doc(spacyDoc)
            Converts a SpaCy Doc object to a processors Document object

        to_spacy_doc(cluDoc, pipeline)
            Converts a processors Document object to a SpaCy Doc object 
    &#34;&#34;&#34;

    @staticmethod
    def to_clu_doc(spacyDoc: SpacyDoc) -&gt; CluDocument:
        &#34;&#34;&#34;
            Converts a SpacyDoc: Sequence[Token] to a CluDocument: Sequence[Sentence]

            Parameters
            ----------
            spacyDoc: a SpacyDoc object

            Returns
            -------
            A CluDocument object
        &#34;&#34;&#34;
        sentences = [] #Initialize List[Sentence]

        for sent in spacyDoc.sents:
            sentences.append(ConverterUtils.make_sentence(sent))

        doc = CluDocument(sentences)
        
        return doc

    @staticmethod
    def to_spacy_doc(cluDoc: Union[CluDocument, str], pipeline = DEFAULT_PIPELINE) -&gt; SpacyDoc:
        &#34;&#34;&#34;
           Converts a CluDocument: Sequence[Sentence] to a SpacyDoc: Sequence[Token]

           Parameters
           ----------
           cluDoc: a processor Document object or path to JSON
           pipeline: spacy pipeline, for vocab object

           Returns
           -------
           A SpacyDocument object
        &#34;&#34;&#34;
        if isinstance(cluDoc, str):
            with open(cluDoc, &#39;r&#39;) as f:
                cluDoc = CluDocument.load_from_JSON(f.read())
        
        nlp = spacy.load(pipeline)

        doc_data = ConverterUtils.make_data(cluDoc)        
        doc = SpacyDoc(nlp.vocab, **doc_data)

        return doc

    ### Helper Methods :

    @staticmethod
    def to_sentence(sent: Span) -&gt; Sentence:
        &#34;&#34;&#34;
            Converts a SpaCy Span (Doc slice) object to a processors Sentence object.

            Parameters
            ----------
            sent: a SpaCy Span object

            Returns
            -------
            sentence: a processors Sentence object
        &#34;&#34;&#34;

        startoffsets, endoffsets = ConverterUtils.spaces_to_offsets(sent)

        params = {
            &#34;text&#34;: sent.text,
            &#34;words&#34;: [token.text for token in sent],
            &#34;startOffsets&#34;: startoffsets,
            &#34;endOffsets&#34;: endoffsets,
            &#34;tags&#34;: [token.tag_ for token in sent],
            &#34;lemmas&#34;: [token.lemma_ for token in sent],
            &#34;chunks&#34;: [&#34;O&#34; for token in sent], # FIXME: SpaCy noun_chunks?
            &#34;entities&#34;: [t.ent_iob_+&#34;-&#34;+t.ent_type_ if t.ent_type_ != &#34;&#34; else &#34;O&#34; for t in sent],
            &#34;graphs&#34;: ConverterUtils.dep_to_graph(sent)
        }

        sentence = Sentence(**params)

        return sentence

    @staticmethod
    def to_dict(cluDoc: CluDocument) -&gt; Dict:
        &#34;&#34;&#34;
            Converts a CluDocument object to a dictionary of Doc attributes.

            Parameters
            ----------
            cluDoc: a processors Document object

            Returns
            -------
            data: a dictionary of SpaCy Doc attributes
        &#34;&#34;&#34;
        spaces = []
        for sent in cluDoc.sentences:
            spaces += ConverterUtils.offsets_to_spaces(sent)
        # assert len(spaces) == len(cluDoc.words)

        heads, deps = ConverterUtils.graph_to_dep(cluDoc)

        data = {
            &#34;words&#34;: cluDoc.words,
            &#34;spaces&#34;: ConverterUtils.offsets_to_spaces(cluDoc),
            &#34;tags&#34;: cluDoc.tags,
            &#34;lemmas&#34;: cluDoc.lemmas,
            &#34;heads&#34;: heads,
            &#34;deps&#34;: deps,
            &#34;ents&#34;: cluDoc._entities
        }
        return data

    @staticmethod
    def spaces_to_offsets(sent: Span) -&gt; Tuple[List[int]]:

        startOffSets = list()
        endOffSets = list()

        for token in sent:
            offset = token.idx - sent.start_char
            startOffSets.append(offset)
            endOffSets.append(offset + len(token))

        assert startOffSets[0] == 0

        return (startOffSets, endOffSets)

    @staticmethod
    def offsets_to_spaces(cluDoc: CluDocument) -&gt; List[bool]:
        # FIXME 
        spaces = []
        # for sent in cluDoc.sentences:
        return spaces

    @staticmethod
    def dep_to_graph(sent: Span) -&gt; Dict:
        graphs = dict()
        # {graph-name: {edges: [{source: int, destination: int, relation: str}], roots: [int]}}

        spacy_graph = dict()

        edges = list() # edges: List[Dict]
        for token in sent:
            children = token.children
            child = ConverterUtils.peek(children)
            while child is not None:
                edge = {&#34;source&#34;: token.i-sent.start, &#34;destination&#34;: child.i-sent.start, &#34;relation&#34;: child.dep_}
                edges.append(edge)
                child = ConverterUtils.peek(children)

        spacy_graph[&#34;edges&#34;] = edges
        spacy_graph[&#34;roots&#34;] = [sent.root.i-sent.start]

        graphs[&#34;stanford-basic&#34;] = spacy_graph

        return graphs    

    @staticmethod
    def graph_to_dep(cluDoc: CluDocument) -&gt; Tuple[List, List]:
        # FIXME
        heads = []
        deps = []
        return (heads, deps)

    @staticmethod
    def _peek(generator: Iterable) -&gt; Union[Token, None]:
        &#34;&#34;&#34;peek() will return either the next Token in the iterable or None.&#34;&#34;&#34;
        try:
            first = next(generator)
        except StopIteration:
            return None
        return first</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clu.spacy.utils.ConverterUtils"><code class="flex name class">
<span>class <span class="ident">ConverterUtils</span></span>
</code></dt>
<dd>
<div class="desc"><p>A collection of utlity methods for coverting between SpaCy Doc and processor Document containers.</p>
<h2 id="supported-containers">Supported Containers</h2>
<p>SpaCy Doc : Sequence[Token]
A sequence of SpaCy Token objects.</p>
<p>CluDocument : Sequence[Sentence]
A sequence of processor Setence objects.</p>
<h2 id="methods">Methods</h2>
<p>to_clu_doc(spacyDoc)
Converts a SpaCy Doc object to a processors Document object</p>
<p>to_spacy_doc(cluDoc, pipeline)
Converts a processors Document object to a SpaCy Doc object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConverterUtils:

    &#34;&#34;&#34;
        A collection of utlity methods for coverting between SpaCy Doc and processor Document containers.

        Supported Containers
        --------------------
        SpaCy Doc : Sequence[Token]
                A sequence of SpaCy Token objects.

        CluDocument : Sequence[Sentence]
                A sequence of processor Setence objects.

        Methods
        -------
        to_clu_doc(spacyDoc)
            Converts a SpaCy Doc object to a processors Document object

        to_spacy_doc(cluDoc, pipeline)
            Converts a processors Document object to a SpaCy Doc object 
    &#34;&#34;&#34;

    @staticmethod
    def to_clu_doc(spacyDoc: SpacyDoc) -&gt; CluDocument:
        &#34;&#34;&#34;
            Converts a SpacyDoc: Sequence[Token] to a CluDocument: Sequence[Sentence]

            Parameters
            ----------
            spacyDoc: a SpacyDoc object

            Returns
            -------
            A CluDocument object
        &#34;&#34;&#34;
        sentences = [] #Initialize List[Sentence]

        for sent in spacyDoc.sents:
            sentences.append(ConverterUtils.make_sentence(sent))

        doc = CluDocument(sentences)
        
        return doc

    @staticmethod
    def to_spacy_doc(cluDoc: Union[CluDocument, str], pipeline = DEFAULT_PIPELINE) -&gt; SpacyDoc:
        &#34;&#34;&#34;
           Converts a CluDocument: Sequence[Sentence] to a SpacyDoc: Sequence[Token]

           Parameters
           ----------
           cluDoc: a processor Document object or path to JSON
           pipeline: spacy pipeline, for vocab object

           Returns
           -------
           A SpacyDocument object
        &#34;&#34;&#34;
        if isinstance(cluDoc, str):
            with open(cluDoc, &#39;r&#39;) as f:
                cluDoc = CluDocument.load_from_JSON(f.read())
        
        nlp = spacy.load(pipeline)

        doc_data = ConverterUtils.make_data(cluDoc)        
        doc = SpacyDoc(nlp.vocab, **doc_data)

        return doc

    ### Helper Methods :

    @staticmethod
    def to_sentence(sent: Span) -&gt; Sentence:
        &#34;&#34;&#34;
            Converts a SpaCy Span (Doc slice) object to a processors Sentence object.

            Parameters
            ----------
            sent: a SpaCy Span object

            Returns
            -------
            sentence: a processors Sentence object
        &#34;&#34;&#34;

        startoffsets, endoffsets = ConverterUtils.spaces_to_offsets(sent)

        params = {
            &#34;text&#34;: sent.text,
            &#34;words&#34;: [token.text for token in sent],
            &#34;startOffsets&#34;: startoffsets,
            &#34;endOffsets&#34;: endoffsets,
            &#34;tags&#34;: [token.tag_ for token in sent],
            &#34;lemmas&#34;: [token.lemma_ for token in sent],
            &#34;chunks&#34;: [&#34;O&#34; for token in sent], # FIXME: SpaCy noun_chunks?
            &#34;entities&#34;: [t.ent_iob_+&#34;-&#34;+t.ent_type_ if t.ent_type_ != &#34;&#34; else &#34;O&#34; for t in sent],
            &#34;graphs&#34;: ConverterUtils.dep_to_graph(sent)
        }

        sentence = Sentence(**params)

        return sentence

    @staticmethod
    def to_dict(cluDoc: CluDocument) -&gt; Dict:
        &#34;&#34;&#34;
            Converts a CluDocument object to a dictionary of Doc attributes.

            Parameters
            ----------
            cluDoc: a processors Document object

            Returns
            -------
            data: a dictionary of SpaCy Doc attributes
        &#34;&#34;&#34;
        spaces = []
        for sent in cluDoc.sentences:
            spaces += ConverterUtils.offsets_to_spaces(sent)
        # assert len(spaces) == len(cluDoc.words)

        heads, deps = ConverterUtils.graph_to_dep(cluDoc)

        data = {
            &#34;words&#34;: cluDoc.words,
            &#34;spaces&#34;: ConverterUtils.offsets_to_spaces(cluDoc),
            &#34;tags&#34;: cluDoc.tags,
            &#34;lemmas&#34;: cluDoc.lemmas,
            &#34;heads&#34;: heads,
            &#34;deps&#34;: deps,
            &#34;ents&#34;: cluDoc._entities
        }
        return data

    @staticmethod
    def spaces_to_offsets(sent: Span) -&gt; Tuple[List[int]]:

        startOffSets = list()
        endOffSets = list()

        for token in sent:
            offset = token.idx - sent.start_char
            startOffSets.append(offset)
            endOffSets.append(offset + len(token))

        assert startOffSets[0] == 0

        return (startOffSets, endOffSets)

    @staticmethod
    def offsets_to_spaces(cluDoc: CluDocument) -&gt; List[bool]:
        # FIXME 
        spaces = []
        # for sent in cluDoc.sentences:
        return spaces

    @staticmethod
    def dep_to_graph(sent: Span) -&gt; Dict:
        graphs = dict()
        # {graph-name: {edges: [{source: int, destination: int, relation: str}], roots: [int]}}

        spacy_graph = dict()

        edges = list() # edges: List[Dict]
        for token in sent:
            children = token.children
            child = ConverterUtils.peek(children)
            while child is not None:
                edge = {&#34;source&#34;: token.i-sent.start, &#34;destination&#34;: child.i-sent.start, &#34;relation&#34;: child.dep_}
                edges.append(edge)
                child = ConverterUtils.peek(children)

        spacy_graph[&#34;edges&#34;] = edges
        spacy_graph[&#34;roots&#34;] = [sent.root.i-sent.start]

        graphs[&#34;stanford-basic&#34;] = spacy_graph

        return graphs    

    @staticmethod
    def graph_to_dep(cluDoc: CluDocument) -&gt; Tuple[List, List]:
        # FIXME
        heads = []
        deps = []
        return (heads, deps)

    @staticmethod
    def _peek(generator: Iterable) -&gt; Union[Token, None]:
        &#34;&#34;&#34;peek() will return either the next Token in the iterable or None.&#34;&#34;&#34;
        try:
            first = next(generator)
        except StopIteration:
            return None
        return first</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="clu.spacy.utils.ConverterUtils.dep_to_graph"><code class="name flex">
<span>def <span class="ident">dep_to_graph</span></span>(<span>sent: spacy.tokens.span.Span) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dep_to_graph(sent: Span) -&gt; Dict:
    graphs = dict()
    # {graph-name: {edges: [{source: int, destination: int, relation: str}], roots: [int]}}

    spacy_graph = dict()

    edges = list() # edges: List[Dict]
    for token in sent:
        children = token.children
        child = ConverterUtils.peek(children)
        while child is not None:
            edge = {&#34;source&#34;: token.i-sent.start, &#34;destination&#34;: child.i-sent.start, &#34;relation&#34;: child.dep_}
            edges.append(edge)
            child = ConverterUtils.peek(children)

    spacy_graph[&#34;edges&#34;] = edges
    spacy_graph[&#34;roots&#34;] = [sent.root.i-sent.start]

    graphs[&#34;stanford-basic&#34;] = spacy_graph

    return graphs    </code></pre>
</details>
</dd>
<dt id="clu.spacy.utils.ConverterUtils.graph_to_dep"><code class="name flex">
<span>def <span class="ident">graph_to_dep</span></span>(<span>cluDoc: processors.ds.Document) ‑> Tuple[List, List]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def graph_to_dep(cluDoc: CluDocument) -&gt; Tuple[List, List]:
    # FIXME
    heads = []
    deps = []
    return (heads, deps)</code></pre>
</details>
</dd>
<dt id="clu.spacy.utils.ConverterUtils.offsets_to_spaces"><code class="name flex">
<span>def <span class="ident">offsets_to_spaces</span></span>(<span>cluDoc: processors.ds.Document) ‑> List[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def offsets_to_spaces(cluDoc: CluDocument) -&gt; List[bool]:
    # FIXME 
    spaces = []
    # for sent in cluDoc.sentences:
    return spaces</code></pre>
</details>
</dd>
<dt id="clu.spacy.utils.ConverterUtils.spaces_to_offsets"><code class="name flex">
<span>def <span class="ident">spaces_to_offsets</span></span>(<span>sent: spacy.tokens.span.Span) ‑> Tuple[List[int]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def spaces_to_offsets(sent: Span) -&gt; Tuple[List[int]]:

    startOffSets = list()
    endOffSets = list()

    for token in sent:
        offset = token.idx - sent.start_char
        startOffSets.append(offset)
        endOffSets.append(offset + len(token))

    assert startOffSets[0] == 0

    return (startOffSets, endOffSets)</code></pre>
</details>
</dd>
<dt id="clu.spacy.utils.ConverterUtils.to_clu_doc"><code class="name flex">
<span>def <span class="ident">to_clu_doc</span></span>(<span>spacyDoc: spacy.tokens.doc.Doc) ‑> processors.ds.Document</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a SpacyDoc: Sequence[Token] to a CluDocument: Sequence[Sentence]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spacyDoc</code></strong> :&ensp;<code>a SpacyDoc object</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A CluDocument object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_clu_doc(spacyDoc: SpacyDoc) -&gt; CluDocument:
    &#34;&#34;&#34;
        Converts a SpacyDoc: Sequence[Token] to a CluDocument: Sequence[Sentence]

        Parameters
        ----------
        spacyDoc: a SpacyDoc object

        Returns
        -------
        A CluDocument object
    &#34;&#34;&#34;
    sentences = [] #Initialize List[Sentence]

    for sent in spacyDoc.sents:
        sentences.append(ConverterUtils.make_sentence(sent))

    doc = CluDocument(sentences)
    
    return doc</code></pre>
</details>
</dd>
<dt id="clu.spacy.utils.ConverterUtils.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>cluDoc: processors.ds.Document) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a CluDocument object to a dictionary of Doc attributes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cluDoc</code></strong> :&ensp;<code>a processors Document object</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>a dictionary</code> of <code>SpaCy Doc attributes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_dict(cluDoc: CluDocument) -&gt; Dict:
    &#34;&#34;&#34;
        Converts a CluDocument object to a dictionary of Doc attributes.

        Parameters
        ----------
        cluDoc: a processors Document object

        Returns
        -------
        data: a dictionary of SpaCy Doc attributes
    &#34;&#34;&#34;
    spaces = []
    for sent in cluDoc.sentences:
        spaces += ConverterUtils.offsets_to_spaces(sent)
    # assert len(spaces) == len(cluDoc.words)

    heads, deps = ConverterUtils.graph_to_dep(cluDoc)

    data = {
        &#34;words&#34;: cluDoc.words,
        &#34;spaces&#34;: ConverterUtils.offsets_to_spaces(cluDoc),
        &#34;tags&#34;: cluDoc.tags,
        &#34;lemmas&#34;: cluDoc.lemmas,
        &#34;heads&#34;: heads,
        &#34;deps&#34;: deps,
        &#34;ents&#34;: cluDoc._entities
    }
    return data</code></pre>
</details>
</dd>
<dt id="clu.spacy.utils.ConverterUtils.to_sentence"><code class="name flex">
<span>def <span class="ident">to_sentence</span></span>(<span>sent: spacy.tokens.span.Span) ‑> processors.ds.Sentence</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a SpaCy Span (Doc slice) object to a processors Sentence object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sent</code></strong> :&ensp;<code>a SpaCy Span object</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>sentence</code></strong> :&ensp;<code>a processors Sentence object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_sentence(sent: Span) -&gt; Sentence:
    &#34;&#34;&#34;
        Converts a SpaCy Span (Doc slice) object to a processors Sentence object.

        Parameters
        ----------
        sent: a SpaCy Span object

        Returns
        -------
        sentence: a processors Sentence object
    &#34;&#34;&#34;

    startoffsets, endoffsets = ConverterUtils.spaces_to_offsets(sent)

    params = {
        &#34;text&#34;: sent.text,
        &#34;words&#34;: [token.text for token in sent],
        &#34;startOffsets&#34;: startoffsets,
        &#34;endOffsets&#34;: endoffsets,
        &#34;tags&#34;: [token.tag_ for token in sent],
        &#34;lemmas&#34;: [token.lemma_ for token in sent],
        &#34;chunks&#34;: [&#34;O&#34; for token in sent], # FIXME: SpaCy noun_chunks?
        &#34;entities&#34;: [t.ent_iob_+&#34;-&#34;+t.ent_type_ if t.ent_type_ != &#34;&#34; else &#34;O&#34; for t in sent],
        &#34;graphs&#34;: ConverterUtils.dep_to_graph(sent)
    }

    sentence = Sentence(**params)

    return sentence</code></pre>
</details>
</dd>
<dt id="clu.spacy.utils.ConverterUtils.to_spacy_doc"><code class="name flex">
<span>def <span class="ident">to_spacy_doc</span></span>(<span>cluDoc: Union[processors.ds.Document, str], pipeline='en_core_web_sm') ‑> spacy.tokens.doc.Doc</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a CluDocument: Sequence[Sentence] to a SpacyDoc: Sequence[Token]</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cluDoc</code></strong> :&ensp;<code>a processor Document object</code> or <code>path to JSON</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>pipeline</code></strong> :&ensp;<code>spacy pipeline, for vocab object</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A SpacyDocument object</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_spacy_doc(cluDoc: Union[CluDocument, str], pipeline = DEFAULT_PIPELINE) -&gt; SpacyDoc:
    &#34;&#34;&#34;
       Converts a CluDocument: Sequence[Sentence] to a SpacyDoc: Sequence[Token]

       Parameters
       ----------
       cluDoc: a processor Document object or path to JSON
       pipeline: spacy pipeline, for vocab object

       Returns
       -------
       A SpacyDocument object
    &#34;&#34;&#34;
    if isinstance(cluDoc, str):
        with open(cluDoc, &#39;r&#39;) as f:
            cluDoc = CluDocument.load_from_JSON(f.read())
    
    nlp = spacy.load(pipeline)

    doc_data = ConverterUtils.make_data(cluDoc)        
    doc = SpacyDoc(nlp.vocab, **doc_data)

    return doc</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clu.spacy" href="index.html">clu.spacy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clu.spacy.utils.ConverterUtils" href="#clu.spacy.utils.ConverterUtils">ConverterUtils</a></code></h4>
<ul class="two-column">
<li><code><a title="clu.spacy.utils.ConverterUtils.dep_to_graph" href="#clu.spacy.utils.ConverterUtils.dep_to_graph">dep_to_graph</a></code></li>
<li><code><a title="clu.spacy.utils.ConverterUtils.graph_to_dep" href="#clu.spacy.utils.ConverterUtils.graph_to_dep">graph_to_dep</a></code></li>
<li><code><a title="clu.spacy.utils.ConverterUtils.offsets_to_spaces" href="#clu.spacy.utils.ConverterUtils.offsets_to_spaces">offsets_to_spaces</a></code></li>
<li><code><a title="clu.spacy.utils.ConverterUtils.spaces_to_offsets" href="#clu.spacy.utils.ConverterUtils.spaces_to_offsets">spaces_to_offsets</a></code></li>
<li><code><a title="clu.spacy.utils.ConverterUtils.to_clu_doc" href="#clu.spacy.utils.ConverterUtils.to_clu_doc">to_clu_doc</a></code></li>
<li><code><a title="clu.spacy.utils.ConverterUtils.to_dict" href="#clu.spacy.utils.ConverterUtils.to_dict">to_dict</a></code></li>
<li><code><a title="clu.spacy.utils.ConverterUtils.to_sentence" href="#clu.spacy.utils.ConverterUtils.to_sentence">to_sentence</a></code></li>
<li><code><a title="clu.spacy.utils.ConverterUtils.to_spacy_doc" href="#clu.spacy.utils.ConverterUtils.to_spacy_doc">to_spacy_doc</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>